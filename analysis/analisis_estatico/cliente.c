#include "cliente.h"


undefined main;
undefined1 completed.0;
pointer __dso_handle;
undefined DAT_00105050;
undefined1[272] cout;
undefined endl<char,std::char_traits<char>>;
undefined DAT_00105218;
undefined DAT_00105009;
undefined __isoc23_strtol;
undefined1[272] cerr;
undefined1[280] cin;
undefined DAT_001053a8;
undefined DAT_001053c8;

int _init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = __gmon_start__();
  return iVar1;
}



void FUN_00102020(void)

{
  (*(code *)(undefined *)0x0)();
  return;
}



void __cxa_finalize(void)

{
  __cxa_finalize();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint16_t htons(uint16_t __hostshort)

{
  uint16_t uVar1;
  
  uVar1 = htons(__hostshort);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

istream * std::getline<>(istream *param_1,string *param_2)

{
  istream *piVar1;
  
  piVar1 = getline<>(param_1,param_2);
  return piVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
  int iVar1;
  
  iVar1 = socket(__domain,__type,__protocol);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t recv(int __fd,void *__buf,size_t __n,int __flags)

{
  ssize_t sVar1;
  
  sVar1 = recv(__fd,__buf,__n,__flags);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__throw_bad_alloc(void)

{
  __throw_bad_alloc();
  return;
}



void __cxa_begin_catch(void)

{
  __cxa_begin_catch();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__cxx11::string::c_str(void)

{
  c_str();
  return;
}



void __thiscall std::__cxx11::string::string(string *this,string *param_1)

{
  string(this,param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t send(int __fd,void *__buf,size_t __n,int __flags)

{
  ssize_t sVar1;
  
  sVar1 = send(__fd,__buf,__n,__flags);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__throw_length_error(char *param_1)

{
  __throw_length_error(param_1);
  return;
}



void __thiscall std::__cxx11::string::string(string *this,string *param_1)

{
  string(this,param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__throw_invalid_argument(char *param_1)

{
  __throw_invalid_argument(param_1);
  return;
}



void __thiscall std::__cxx11::string::~string(string *this)

{
  ~string(this);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__cxx11::string::size(void)

{
  size();
  return;
}



void __thiscall std::__cxx11::stringstream::stringstream(stringstream *this)

{
  stringstream(this);
  return;
}



void __thiscall std::__cxx11::stringstream::~stringstream(stringstream *this)

{
  ~stringstream(this);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__throw_bad_array_new_length(void)

{
  __throw_bad_array_new_length();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = connect(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ostream * std::operator<<(ostream *param_1,string *param_2)

{
  ostream *poVar1;
  
  poVar1 = operator<<(param_1,param_2);
  return poVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void operator_delete(void *param_1)

{
  operator_delete(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__cxx11::string::begin(void)

{
  begin();
  return;
}



void __thiscall std::__cxx11::string::operator+=(string *this,char *param_1)

{
  operator+=(this,param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__cxx11::stringstream::str(void)

{
  str();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ostream * std::operator<<(ostream *param_1,char *param_2)

{
  ostream *poVar1;
  
  poVar1 = operator<<(param_1,param_2);
  return poVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * operator_new(ulong param_1)

{
  void *pvVar1;
  
  pvVar1 = operator_new(param_1);
  return pvVar1;
}



void __thiscall std::ostream::operator<<(void *this,_func_ostream_ptr_ostream_ptr *param_1)

{
  operator<<(this,param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__cxx11::string::operator[](ulong param_1)

{
  operator[](param_1);
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __thiscall std::__cxx11::string::operator=(string *this,string *param_1)

{
  operator=(this,param_1);
  return;
}



bool __thiscall std::ios::operator_cast_to_bool(ios *this)

{
  bool bVar1;
  
  bVar1 = operator_cast_to_bool(this);
  return bVar1;
}



void __thiscall std::__cxx11::string::string(string *this,char *param_1,allocator *param_2)

{
  string(this,param_1,param_2);
  return;
}



void __thiscall std::__cxx11::string::string(string *this)

{
  string(this);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__throw_out_of_range(char *param_1)

{
  __throw_out_of_range(param_1);
  return;
}



void __cxa_rethrow(void)

{
  __cxa_rethrow();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__cxx11::string::length(void)

{
  length();
  return;
}



void __thiscall
std::__cxx11::stringstream::stringstream(stringstream *this,string *param_1,_Ios_Openmode param_2)

{
  stringstream(this,param_1,param_2);
  return;
}



void __cxa_end_catch(void)

{
  __cxa_end_catch();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__cxx11::string::empty(void)

{
  empty();
  return;
}



void __thiscall std::ostream::operator<<(void *this,int param_1)

{
  operator<<(this,param_1);
  return;
}



void _Unwind_Resume(void)

{
                    // WARNING: Subroutine does not return
  _Unwind_Resume();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

istream * std::getline<>(istream *param_1,string *param_2,char param_3)

{
  istream *piVar1;
  
  piVar1 = getline<>(param_1,param_2,param_3);
  return piVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::__cxx11::string::end(void)

{
  end();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int inet_pton(int __af,char *__cp,void *__buf)

{
  int iVar1;
  
  iVar1 = inet_pton(__af,__cp,__buf);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



void processEntry _start(undefined8 param_1,undefined8 param_2)

{
  undefined1 auStack_8 [8];
  
  __libc_start_main(main,param_2,&stack0x00000008,0,0,param_1,auStack_8);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x00102623)
// WARNING: Removing unreachable block (ram,0x0010262f)

void deregister_tm_clones(void)

{
  return;
}



// WARNING: Removing unreachable block (ram,0x00102664)
// WARNING: Removing unreachable block (ram,0x00102670)

void register_tm_clones(void)

{
  return;
}



void __do_global_dtors_aux(void)

{
  if (completed_0 != '\0') {
    return;
  }
  __cxa_finalize(__dso_handle);
  deregister_tm_clones();
  completed_0 = 1;
  return;
}



void frame_dummy(void)

{
  register_tm_clones();
  return;
}



// WARNING: Unknown calling convention

int main(void)

{
  long lVar1;
  bool bVar2;
  char cVar3;
  ostream *poVar4;
  void *this;
  int iVar5;
  int iVar6;
  string *psVar7;
  long in_FS_OFFSET;
  int puerto;
  ClienteRed cliente;
  string ip_servidor;
  string puerto_str;
  string respuesta;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  poVar4 = std::operator<<((ostream *)std::cout,&DAT_00105050);
  std::ostream::operator<<(poVar4,std::endl<>);
  std::__cxx11::string::string((string *)&ip_servidor);
  while( true ) {
                    // try { // try from 00102747 to 0010274b has its CatchHandler @ 00102b8d
    std::__cxx11::string::string
              ((string *)&puerto_str,"Ingresa la IP del servidor: ",(allocator *)&cliente);
                    // try { // try from 0010275a to 0010275e has its CatchHandler @ 00102b78
    Validador::pedirEntrada(&respuesta,&puerto_str);
    psVar7 = &respuesta;
    std::__cxx11::string::operator=((string *)&ip_servidor,(string *)psVar7);
    iVar6 = (int)psVar7;
    std::__cxx11::string::~string((string *)&respuesta);
    std::__cxx11::string::~string((string *)&puerto_str);
    std::__new_allocator<char>::~__new_allocator((__new_allocator<char> *)&cliente,iVar6);
                    // try { // try from 001027a1 to 001027a5 has its CatchHandler @ 00102d19
    bVar2 = Validador::IP_valida(&ip_servidor);
    if (bVar2) break;
    iVar6 = 0x10509f;
                    // try { // try from 001027d7 to 001027db has its CatchHandler @ 00102bbe
    std::__cxx11::string::string((string *)&respuesta,"IP invalida ",(allocator *)&cliente);
                    // try { // try from 001027e3 to 001027e7 has its CatchHandler @ 00102ba9
    ManejadorErrores::mostrarError(&respuesta);
    std::__cxx11::string::~string((string *)&respuesta);
    std::__new_allocator<char>::~__new_allocator((__new_allocator<char> *)&cliente,iVar6);
                    // try { // try from 00102818 to 00102884 has its CatchHandler @ 00102d19
    poVar4 = std::operator<<((ostream *)std::cout," Ejemplos validos de la ip:");
    std::ostream::operator<<(poVar4,std::endl<>);
    poVar4 = std::operator<<((ostream *)std::cout,
                             " 127.0.0.1 (la misma computadora es el cliente y el servidor)");
    std::ostream::operator<<(poVar4,std::endl<>);
    poVar4 = std::operator<<((ostream *)std::cout," 192.168.1.100 (otra computadora es el servidor)"
                            );
    std::ostream::operator<<(poVar4,std::endl<>);
  }
  do {
                    // try { // try from 001028b2 to 001028b6 has its CatchHandler @ 00102bef
    std::__cxx11::string::string
              ((string *)&respuesta,
               " Ingresa el puerto (si presiona enter sin haber ingresado un puerto, el puerto por defecto sera el 8080): "
               ,(allocator *)&cliente);
    psVar7 = &respuesta;
                    // try { // try from 001028c5 to 001028c9 has its CatchHandler @ 00102bda
    Validador::pedirEntrada(&puerto_str,psVar7);
    iVar6 = (int)psVar7;
    std::__cxx11::string::~string((string *)&respuesta);
    std::__new_allocator<char>::~__new_allocator((__new_allocator<char> *)&cliente,iVar6);
    cVar3 = std::__cxx11::string::empty();
    if (cVar3 == '\0') {
                    // try { // try from 00102918 to 0010292f has its CatchHandler @ 00102c0b
      puerto = std::__cxx11::stoi(&puerto_str,(size_t *)0x0,10);
      bVar2 = Validador::Puerto_valido(puerto);
      if (bVar2) {
        bVar2 = false;
      }
      else {
        bVar2 = true;
      }
    }
    else {
      puerto = 0x1f90;
      bVar2 = false;
    }
    std::__cxx11::string::~string((string *)&puerto_str);
  } while (bVar2);
  iVar6 = 0x1051b0;
                    // try { // try from 0010297e to 00102982 has its CatchHandler @ 00102cd3
  std::__cxx11::string::string
            ((string *)&respuesta,"La configuracion fue validada correctamente",
             (allocator *)&cliente);
                    // try { // try from 0010298a to 0010298e has its CatchHandler @ 00102cbe
  ManejadorErrores::mostrarExito(&respuesta);
  std::__cxx11::string::~string((string *)&respuesta);
  std::__new_allocator<char>::~__new_allocator((__new_allocator<char> *)&cliente,iVar6);
                    // try { // try from 001029bf to 00102a1e has its CatchHandler @ 00102d19
  poVar4 = std::operator<<((ostream *)std::cout," Conectando a: ");
  poVar4 = std::operator<<(poVar4,(string *)&ip_servidor);
  poVar4 = std::operator<<(poVar4,":");
  this = (void *)std::ostream::operator<<(poVar4,puerto);
  std::ostream::operator<<(this,std::endl<>);
  ClienteRed::ClienteRed(&cliente);
  psVar7 = &ip_servidor;
                    // try { // try from 00102a36 to 00102ab3 has its CatchHandler @ 00102d01
  bVar2 = ClienteRed::conectar(&cliente,psVar7,puerto);
  iVar6 = (int)psVar7;
  if (bVar2) {
    psVar7 = &ip_servidor;
    bVar2 = ClienteRed::enviarPeticion(&cliente,psVar7);
    iVar6 = (int)psVar7;
    if (bVar2) {
      poVar4 = std::operator<<((ostream *)std::cout,"Esperando a que le servidor responda ");
      std::ostream::operator<<(poVar4,std::endl<>);
      ClienteRed::recibirRespuesta(&respuesta,&cliente);
                    // try { // try from 00102ac8 to 00102b31 has its CatchHandler @ 00102cec
      poVar4 = std::operator<<((ostream *)std::cout,&DAT_00105218);
      std::ostream::operator<<(poVar4,std::endl<>);
      poVar4 = std::operator<<((ostream *)std::cout,(string *)&respuesta);
      std::ostream::operator<<(poVar4,std::endl<>);
      poVar4 = std::operator<<((ostream *)std::cout,"Sesion finalizada ");
      iVar6 = 0x109048;
      std::ostream::operator<<(poVar4,std::endl<>);
      iVar5 = 0;
      std::__cxx11::string::~string((string *)&respuesta);
    }
    else {
      iVar5 = 1;
    }
  }
  else {
    iVar5 = 1;
  }
  ClienteRed::~ClienteRed(&cliente,iVar6);
  std::__cxx11::string::~string((string *)&ip_servidor);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// DWARF original name: operator new

void * operator_new(size_t param_1,void *__p)

{
  void *__p_local;
  size_t param_0_local;
  
  return __p;
}



// DWARF original name: operator delete

void operator_delete(void *param_1,void *param_2)

{
  void *param_1_local;
  void *param_0_local;
  
  return;
}



int std::__cxx11::stoi(string *__str,size_t *__idx,int __base)

{
  int iVar1;
  char *__name;
  int __base_local;
  size_t *__idx_local;
  string *__str_local;
  
  __name = (char *)std::__cxx11::string::c_str();
  iVar1 = __gnu_cxx::__stoa<>((__gnu_cxx *)__isoc23_strtol,
                              (_func_long_char_ptr_char_ptr_ptr_int *)&DAT_00105009,__name,
                              (char *)__idx,(size_t *)(ulong)(uint)__base);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

_Ios_Openmode std::operator|(_Ios_Openmode __a,_Ios_Openmode __b)

{
  _Ios_Openmode __b_local;
  _Ios_Openmode __a_local;
  
  return __a | __b;
}



// DWARF original prototype: void ~_Vector_impl(_Vector_impl * this, int __in_chrg)

void __thiscall std::_Vector_base<>::_Vector_impl::~_Vector_impl(_Vector_impl *this,int __in_chrg)

{
  _Vector_impl *this_local;
  
  __new_allocator<>::~__new_allocator((__new_allocator<> *)this,__in_chrg);
  return;
}



// DWARF original prototype: void
// _Vector_base(_Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this)

void __thiscall std::_Vector_base<>::_Vector_base(_Vector_base<> *this)

{
  _Vector_base<> *this_local;
  
  _Vector_impl::_Vector_impl(&this->_M_impl);
  return;
}



// DWARF original prototype: void
// vector(vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this)

void __thiscall std::vector<>::vector(vector<> *this)

{
  vector<> *this_local;
  
  _Vector_base<>::_Vector_base
            (&this->
              super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
            );
  return;
}



bool Validador::IP_valida(string *ip)

{
  long lVar1;
  bool bVar2;
  char cVar3;
  _Ios_Openmode _Var4;
  int iVar5;
  istream *piVar6;
  size_type sVar7;
  reference __str;
  byte *pbVar8;
  ulong uVar9;
  char *pcVar10;
  int __in_chrg;
  string *psVar11;
  __normal_iterator<> *__rhs;
  long in_FS_OFFSET;
  string *ip_local;
  char c;
  int convertir_num;
  iterator __for_begin;
  iterator __for_end;
  const_iterator __for_begin_1;
  const_iterator __for_end_1;
  vector<> *__for_range;
  string *parte;
  basic_string<> *__for_range_1;
  vector<> partes;
  string segmento;
  stringstream ss;
  __normal_iterator<> *__rhs_00;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  _Var4 = std::operator|(_S_out,_S_in);
  std::__cxx11::stringstream::stringstream((stringstream *)&ss,(string *)ip,_Var4);
  std::__cxx11::string::string((string *)&segmento);
  std::vector<>::vector(&partes);
  while( true ) {
    psVar11 = &segmento;
    piVar6 = std::getline<>((istream *)&ss,(string *)psVar11,'.');
    __in_chrg = (int)psVar11;
    bVar2 = std::ios::operator_cast_to_bool((ios *)(piVar6 + *(long *)(*(long *)piVar6 + -0x18)));
    if (!bVar2) break;
                    // try { // try from 00102ecf to 00103055 has its CatchHandler @ 00103134
    std::vector<>::push_back(&partes,&segmento);
  }
  sVar7 = std::vector<>::size(&partes);
  if (sVar7 == 4) {
    __for_begin = std::vector<>::begin(&partes);
    __for_end = std::vector<>::end(&partes);
    while( true ) {
      __rhs_00 = &__for_end;
      bVar2 = __gnu_cxx::operator!=<>(&__for_begin,__rhs_00);
      __in_chrg = (int)__rhs_00;
      if (!bVar2) break;
      __str = __gnu_cxx::__normal_iterator<>::operator*(&__for_begin);
      cVar3 = std::__cxx11::string::empty();
      if (cVar3 != '\0') {
        bVar2 = false;
        goto LAB_001030f4;
      }
      __for_begin_1._M_current = (char *)std::__cxx11::string::begin();
      __for_end_1._M_current = (char *)std::__cxx11::string::end();
      while( true ) {
        __rhs = &__for_end_1;
        bVar2 = __gnu_cxx::operator!=<>(&__for_begin_1,__rhs);
        __in_chrg = (int)__rhs;
        if (!bVar2) break;
        pbVar8 = (byte *)__gnu_cxx::__normal_iterator<>::operator*(&__for_begin_1);
        if (9 < *pbVar8 - 0x30) {
          bVar2 = false;
          goto LAB_001030f4;
        }
        __gnu_cxx::__normal_iterator<>::operator++(&__for_begin_1);
      }
      __in_chrg = 0;
      iVar5 = std::__cxx11::stoi(__str,(size_t *)0x0,10);
      if ((iVar5 < 0) || (0xff < iVar5)) {
        bVar2 = false;
        goto LAB_001030f4;
      }
      uVar9 = std::__cxx11::string::size();
      if (uVar9 < 2) {
LAB_001030af:
        bVar2 = false;
      }
      else {
        __in_chrg = 0;
        pcVar10 = (char *)std::__cxx11::string::operator[]((ulong)__str);
        if (*pcVar10 != '0') goto LAB_001030af;
        bVar2 = true;
      }
      if (bVar2) {
        bVar2 = false;
        goto LAB_001030f4;
      }
      __gnu_cxx::__normal_iterator<>::operator++(&__for_begin);
    }
    bVar2 = true;
  }
  else {
    bVar2 = false;
  }
LAB_001030f4:
  std::vector<>::~vector(&partes,__in_chrg);
  std::__cxx11::string::~string((string *)&segmento);
  std::__cxx11::stringstream::~stringstream((stringstream *)&ss);
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return bVar2;
}



bool Validador::Puerto_valido(int puerto)

{
  bool bVar1;
  int puerto_local;
  
  if ((puerto < 1) || (0xffff < puerto)) {
    std::operator<<((ostream *)std::cerr,"Error: El puerto debe estar entre 1 y 65535 \n");
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  return bVar1;
}



string * Validador::pedirEntrada(string *__return_storage_ptr__,string *mensaje)

{
  string *mensaje_local;
  string *entrada;
  
  std::__cxx11::string::string((string *)__return_storage_ptr__);
                    // try { // try from 00103209 to 00103223 has its CatchHandler @ 00103226
  std::operator<<((ostream *)std::cout,(string *)mensaje);
  std::getline<>((istream *)std::cin,(string *)__return_storage_ptr__);
  return __return_storage_ptr__;
}



void ManejadorErrores::mostrarError(string *mensaje)

{
  ostream *poVar1;
  string *mensaje_local;
  
  poVar1 = std::operator<<((ostream *)std::cerr,"ERROR: ");
  poVar1 = std::operator<<(poVar1,(string *)mensaje);
  std::ostream::operator<<(poVar1,std::endl<>);
  return;
}



void ManejadorErrores::mostrarExito(string *mensaje)

{
  ostream *poVar1;
  string *mensaje_local;
  
  poVar1 = std::operator<<((ostream *)std::cout,"Exito ");
  poVar1 = std::operator<<(poVar1,(string *)mensaje);
  std::ostream::operator<<(poVar1,std::endl<>);
  return;
}



// DWARF original prototype: void _Save_errno(_Save_errno * this)

void __thiscall __gnu_cxx::__stoa<>::_Save_errno::_Save_errno(_Save_errno *this)

{
  int *piVar1;
  _Save_errno *this_local;
  
  piVar1 = __errno_location();
  this->_M_errno = *piVar1;
  piVar1 = __errno_location();
  *piVar1 = 0;
  return;
}



// DWARF original prototype: void ~_Save_errno(_Save_errno * this, int __in_chrg)

void __thiscall __gnu_cxx::__stoa<>::_Save_errno::~_Save_errno(_Save_errno *this,int __in_chrg)

{
  int *piVar1;
  _Save_errno *this_local;
  
  piVar1 = __errno_location();
  if (*piVar1 == 0) {
    piVar1 = __errno_location();
    *piVar1 = this->_M_errno;
  }
  return;
}



bool __gnu_cxx::__stoa<>::_Range_chk::_S_chk(long __val)

{
  bool bVar1;
  long __val_local;
  
  if ((__val < -0x80000000) || (0x7fffffff < __val)) {
    bVar1 = true;
  }
  else {
    bVar1 = false;
  }
  return bVar1;
}



// DWARF original name: __stoa<long int, int, char, int>

int __thiscall
__gnu_cxx::__stoa<>(__gnu_cxx *this,_func_long_char_ptr_char_ptr_ptr_int *__convf,char *__name,
                   char *__str,size_t *__idx)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  int __in_chrg;
  char **ppcVar4;
  long in_FS_OFFSET;
  size_t *__idx_local;
  char *__str_local;
  char *__name_local;
  _func_long_char_ptr_char_ptr_ptr_int *__convf_local;
  _Save_errno __save_errno;
  int __ret;
  char *__endptr;
  long __tmp;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  __stoa<>::_Save_errno::_Save_errno(&__save_errno);
  ppcVar4 = &__endptr;
                    // try { // try from 001033cb to 00103447 has its CatchHandler @ 0010348a
  __tmp = (*(code *)this)(__name,ppcVar4,(ulong)__idx & 0xffffffff);
  __in_chrg = (int)ppcVar4;
  if (__name == __endptr) {
    if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    std::__throw_invalid_argument((char *)__convf);
  }
  piVar3 = __errno_location();
  if (*piVar3 != 0x22) {
    bVar1 = __stoa<>::_Range_chk::_S_chk(__tmp);
    if (!bVar1) {
      bVar1 = false;
      goto LAB_00103424;
    }
  }
  bVar1 = true;
LAB_00103424:
  if (bVar1) {
    if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    std::__throw_out_of_range((char *)__convf);
  }
  iVar2 = (int)__tmp;
  if (__str != (char *)0x0) {
    *(long *)__str = (long)__endptr - (long)__name;
  }
  __stoa<>::_Save_errno::~_Save_errno(&__save_errno,__in_chrg);
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



// DWARF original prototype: void _Vector_impl(_Vector_impl * this)

void __thiscall std::_Vector_base<>::_Vector_impl::_Vector_impl(_Vector_impl *this)

{
  _Vector_impl *this_local;
  
  _Vector_impl_data::_Vector_impl_data(&this->super__Vector_impl_data);
  return;
}



// DWARF original prototype: void
// ~_Vector_base(_Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this, int __in_chrg)

void __thiscall std::_Vector_base<>::~_Vector_base(_Vector_base<> *this,int __in_chrg)

{
  pointer __p;
  _Vector_base<> *this_local;
  
  __p = (this->_M_impl).super__Vector_impl_data._M_start;
  _M_deallocate(this,__p,(long)(this->_M_impl).super__Vector_impl_data._M_end_of_storage -
                         (long)(this->_M_impl).super__Vector_impl_data._M_start >> 5);
  _Vector_impl::~_Vector_impl(&this->_M_impl,(int)__p);
  return;
}



// DWARF original prototype: void
// ~vector(vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this, int __in_chrg)

void __thiscall std::vector<>::~vector(vector<> *this,int __in_chrg)

{
  basic_string<> *__last;
  vector<> *this_local;
  
  _Vector_base<>::_M_get_Tp_allocator
            (&this->
              super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
            );
  __last = (this->
           super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
           )._M_impl.super__Vector_impl_data._M_finish;
  _Destroy<>((this->
             super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
             )._M_impl.super__Vector_impl_data._M_start,__last);
  _Vector_base<>::~_Vector_base
            (&this->
              super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
             ,(int)__last);
  return;
}



// DWARF original prototype: void
// push_back(vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this, value_type * __x)

void __thiscall std::vector<>::push_back(vector<> *this,value_type *__x)

{
  pointer __p;
  basic_string<> *pbVar1;
  string *this_00;
  iterator __position;
  value_type *__x_local;
  vector<> *this_local;
  
  if ((this->
      super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
      )._M_impl.super__Vector_impl_data._M_finish ==
      (this->
      super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
      )._M_impl.super__Vector_impl_data._M_end_of_storage) {
    __position = end(this);
    _M_realloc_insert<>(this,__position);
  }
  else {
    __p = (this->
          super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
          )._M_impl.super__Vector_impl_data._M_finish;
    pbVar1 = forward<>(__x);
    this_00 = (string *)operator_new(0x20,__p);
    pbVar1 = forward<>(pbVar1);
                    // try { // try from 00103642 to 00103646 has its CatchHandler @ 0010365f
    std::__cxx11::string::string(this_00,(string *)pbVar1);
    (this->
    super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
    )._M_impl.super__Vector_impl_data._M_finish =
         (this->
         super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
         )._M_impl.super__Vector_impl_data._M_finish + 1;
  }
  return;
}



// DWARF original prototype: size_type
// size(vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this)

size_type __thiscall std::vector<>::size(vector<> *this)

{
  vector<> *this_local;
  
  return (long)(this->
               super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
               )._M_impl.super__Vector_impl_data._M_finish -
         (long)(this->
               super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
               )._M_impl.super__Vector_impl_data._M_start >> 5;
}



// DWARF original prototype: iterator
// begin(vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this)

iterator __thiscall std::vector<>::begin(vector<> *this)

{
  long in_FS_OFFSET;
  vector<> *this_local;
  __normal_iterator<> local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __gnu_cxx::__normal_iterator<>::__normal_iterator(&local_18,(basic_string<> **)this);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (iterator)local_18._M_current;
}



// DWARF original prototype: iterator
// end(vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this)

iterator __thiscall std::vector<>::end(vector<> *this)

{
  long in_FS_OFFSET;
  vector<> *this_local;
  __normal_iterator<> local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __gnu_cxx::__normal_iterator<>::__normal_iterator
            (&local_18,
             &(this->
              super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
              )._M_impl.super__Vector_impl_data._M_finish);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (iterator)local_18._M_current;
}



// DWARF original name: operator!=<std::__cxx11::basic_string<char>*,
// std::vector<std::__cxx11::basic_string<char> > >

bool __gnu_cxx::operator!=<>(__normal_iterator<> *__lhs,__normal_iterator<> *__rhs)

{
  basic_string<> *pbVar1;
  basic_string<> **ppbVar2;
  __normal_iterator<> *__rhs_local;
  __normal_iterator<> *__lhs_local;
  
  ppbVar2 = __normal_iterator<>::base(__lhs);
  pbVar1 = *ppbVar2;
  ppbVar2 = __normal_iterator<>::base(__rhs);
  return pbVar1 != *ppbVar2;
}



// DWARF original prototype:
// __normal_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*,_std::vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>_>
// * 
// operator++(__normal_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*,_std::vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>_>
// * this)

__normal_iterator<> * __thiscall
__gnu_cxx::__normal_iterator<>::operator++(__normal_iterator<> *this)

{
  __normal_iterator<> *this_local;
  
  this->_M_current = this->_M_current + 1;
  return this;
}



// DWARF original prototype: reference
// operator*(__normal_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*,_std::vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>_>
// * this)

reference __thiscall __gnu_cxx::__normal_iterator<>::operator*(__normal_iterator<> *this)

{
  __normal_iterator<> *this_local;
  
  return this->_M_current;
}



// DWARF original name: operator!=<char const*, std::__cxx11::basic_string<char> >

bool __gnu_cxx::operator!=<>(__normal_iterator<> *__lhs,__normal_iterator<> *__rhs)

{
  char *pcVar1;
  char **ppcVar2;
  __normal_iterator<> *__rhs_local;
  __normal_iterator<> *__lhs_local;
  
  ppcVar2 = __normal_iterator<>::base(__lhs);
  pcVar1 = *ppcVar2;
  ppcVar2 = __normal_iterator<>::base(__rhs);
  return pcVar1 != *ppcVar2;
}



// DWARF original prototype:
// __normal_iterator<char_const*,_std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>
// * 
// operator++(__normal_iterator<char_const*,_std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>
// * this)

__normal_iterator<> * __thiscall
__gnu_cxx::__normal_iterator<>::operator++(__normal_iterator<> *this)

{
  __normal_iterator<> *this_local;
  
  this->_M_current = this->_M_current + 1;
  return this;
}



// DWARF original prototype: reference
// operator*(__normal_iterator<char_const*,_std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>
// * this)

reference __thiscall __gnu_cxx::__normal_iterator<>::operator*(__normal_iterator<> *this)

{
  __normal_iterator<> *this_local;
  
  return this->_M_current;
}



// DWARF original prototype: void ~__new_allocator(__new_allocator<char> * this, int __in_chrg)

void __thiscall
std::__new_allocator<char>::~__new_allocator(__new_allocator<char> *this,int __in_chrg)

{
  __new_allocator<char> *this_local;
  
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

type * std::move<>(basic_string<> *__t)

{
  basic_string<> *__t_local;
  
  return __t;
}



// DWARF original prototype: void _Vector_impl_data(_Vector_impl_data * this)

void __thiscall std::_Vector_base<>::_Vector_impl_data::_Vector_impl_data(_Vector_impl_data *this)

{
  _Vector_impl_data *this_local;
  
  this->_M_start = (pointer)0x0;
  this->_M_finish = (pointer)0x0;
  this->_M_end_of_storage = (pointer)0x0;
  return;
}



// DWARF original prototype: void
// ~__new_allocator(__new_allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>
// * this, int __in_chrg)

void __thiscall std::__new_allocator<>::~__new_allocator(__new_allocator<> *this,int __in_chrg)

{
  __new_allocator<> *this_local;
  
  return;
}



// DWARF original prototype: void
// _M_deallocate(_Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this, pointer __p, size_t __n)

void __thiscall std::_Vector_base<>::_M_deallocate(_Vector_base<> *this,pointer __p,size_t __n)

{
  size_t __n_local;
  pointer __p_local;
  _Vector_base<> *this_local;
  
  if (__p != (pointer)0x0) {
    __new_allocator<>::deallocate((__new_allocator<> *)this,__p,__n);
  }
  return;
}



// DWARF original prototype: _Tp_alloc_type *
// _M_get_Tp_allocator(_Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this)

_Tp_alloc_type * __thiscall std::_Vector_base<>::_M_get_Tp_allocator(_Vector_base<> *this)

{
  _Vector_base<> *this_local;
  
  return (_Tp_alloc_type *)this;
}



// WARNING: Unknown calling convention

bool std::vector<>::_S_use_relocate(void)

{
  long lVar1;
  bool bVar2;
  long in_FS_OFFSET;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  bVar2 = _S_nothrow_relocate();
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return bVar2;
}



// WARNING: Unknown calling convention

bool std::vector<>::_S_nothrow_relocate(void)

{
  return true;
}



// DWARF original name: _M_realloc_insert<const std::__cxx11::basic_string<char,
// std::char_traits<char>, std::allocator<char> >&>
// DWARF original prototype: void
// _M_realloc_insert<const_std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>&>(vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this, iterator __position)

void __thiscall std::vector<>::_M_realloc_insert<>(vector<> *this,iterator __position)

{
  bool bVar1;
  string *this_00;
  basic_string<> *pbVar2;
  _Tp_alloc_type *p_Var3;
  basic_string<> **ppbVar4;
  pointer pbVar5;
  type *in_RDX;
  long in_FS_OFFSET;
  iterator __position_local;
  vector<> *this_local;
  __normal_iterator<> local_e8;
  pointer __new_finish;
  size_type __len;
  pointer __old_start;
  pointer __old_finish;
  size_type __elems_before;
  pointer __new_start;
  vector<> *local_b0;
  pointer local_a8;
  basic_string<> *local_a0;
  vector<> *local_98;
  pointer local_90;
  type *local_88;
  pointer local_80;
  pointer local_78;
  _Tp_alloc_type *local_70;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  __position_local = __position;
  __len = _M_check_len(this,1,"vector::_M_realloc_insert");
  __old_start = (this->
                super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                )._M_impl.super__Vector_impl_data._M_start;
  __old_finish = (this->
                 super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                 )._M_impl.super__Vector_impl_data._M_finish;
  local_e8._M_current = (basic_string<> *)begin(this);
  __elems_before = __gnu_cxx::operator-<>(&__position_local,&local_e8);
  __new_finish = _Vector_base<>::_M_allocate
                           (&this->
                             super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                            ,__len);
  __new_start = __new_finish;
  local_a0 = forward<>(in_RDX);
  local_a8 = __new_start + __elems_before;
  local_b0 = this;
  local_88 = forward<>(local_a0);
  local_98 = local_b0;
  local_90 = local_a8;
  this_00 = (string *)operator_new(0x20,local_a8);
  pbVar2 = forward<>(local_88);
                    // try { // try from 00103afa to 00103afe has its CatchHandler @ 00103b1b
  std::__cxx11::string::string(this_00,(string *)pbVar2);
  __new_finish = (pointer)0x0;
  bVar1 = _S_use_relocate();
  if (bVar1) {
    p_Var3 = _Vector_base<>::_M_get_Tp_allocator
                       (&this->
                         super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                       );
    ppbVar4 = __gnu_cxx::__normal_iterator<>::base(&__position_local);
    pbVar5 = _S_relocate(__old_start,*ppbVar4,__new_start,p_Var3);
    __new_finish = pbVar5 + 1;
    p_Var3 = _Vector_base<>::_M_get_Tp_allocator
                       (&this->
                         super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                       );
    ppbVar4 = __gnu_cxx::__normal_iterator<>::base(&__position_local);
    __new_finish = _S_relocate(*ppbVar4,__old_finish,__new_finish,p_Var3);
  }
  else {
    p_Var3 = _Vector_base<>::_M_get_Tp_allocator
                       (&this->
                         super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                       );
    ppbVar4 = __gnu_cxx::__normal_iterator<>::base(&__position_local);
                    // try { // try from 00103c07 to 00103c57 has its CatchHandler @ 00103d36
    pbVar2 = __uninitialized_move_if_noexcept_a<>(__old_start,*ppbVar4,__new_start,p_Var3);
    __new_finish = pbVar2 + 1;
    p_Var3 = _Vector_base<>::_M_get_Tp_allocator
                       (&this->
                         super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                       );
    ppbVar4 = __gnu_cxx::__normal_iterator<>::base(&__position_local);
    __new_finish = __uninitialized_move_if_noexcept_a<>(*ppbVar4,__old_finish,__new_finish,p_Var3);
  }
  bVar1 = _S_use_relocate();
  if (!bVar1) {
    local_70 = _Vector_base<>::_M_get_Tp_allocator
                         (&this->
                           super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                         );
    local_80 = __old_start;
    local_78 = __old_finish;
    _Destroy<>(__old_start,__old_finish);
  }
  _Vector_base<>::_M_deallocate
            (&this->
              super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
             ,__old_start,
             (long)(this->
                   super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                   )._M_impl.super__Vector_impl_data._M_end_of_storage - (long)__old_start >> 5);
  (this->
  super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
  )._M_impl.super__Vector_impl_data._M_start = __new_start;
  (this->
  super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
  )._M_impl.super__Vector_impl_data._M_finish = __new_finish;
  (this->
  super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
  )._M_impl.super__Vector_impl_data._M_end_of_storage = __new_start + __len;
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// DWARF original prototype: void
// __normal_iterator(__normal_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*,_std::vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>_>
// * this, basic_string<char,_std::char_traits<char>,_std::allocator<char>_> * * __i)

void __thiscall
__gnu_cxx::__normal_iterator<>::__normal_iterator(__normal_iterator<> *this,basic_string<> **__i)

{
  basic_string<> **__i_local;
  __normal_iterator<> *this_local;
  
  this->_M_current = *__i;
  return;
}



// DWARF original prototype: basic_string<char,_std::char_traits<char>,_std::allocator<char>_> * *
// base(__normal_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*,_std::vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>_>
// * this)

basic_string<> ** __thiscall __gnu_cxx::__normal_iterator<>::base(__normal_iterator<> *this)

{
  __normal_iterator<> *this_local;
  
  return &this->_M_current;
}



// DWARF original prototype: char * *
// base(__normal_iterator<char_const*,_std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>
// * this)

char ** __thiscall __gnu_cxx::__normal_iterator<>::base(__normal_iterator<> *this)

{
  __normal_iterator<> *this_local;
  
  return &this->_M_current;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: __addressof<std::__cxx11::basic_string<char> >

basic_string<> * std::__addressof<>(basic_string<> *__r)

{
  basic_string<> *__r_local;
  
  return __r;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void std::_Destroy<>(basic_string<> *__first,basic_string<> *__last)

{
  basic_string<> *__last_local;
  basic_string<> *__first_local;
  
  _Destroy_aux<false>::__destroy<>(__first,__last);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<const std::__cxx11::basic_string<char>&>

basic_string<> * std::forward<>(type *__t)

{
  type *__t_local;
  
  return __t;
}



// DWARF original prototype: size_type
// _M_check_len(vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this, size_type __n, char * __s)

size_type __thiscall std::vector<>::_M_check_len(vector<> *this,size_type __n,char *__s)

{
  size_type sVar1;
  size_type sVar2;
  ulong *puVar3;
  long in_FS_OFFSET;
  char *__s_local;
  size_type __n_local;
  vector<> *this_local;
  size_type local_30;
  size_type __len;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  __n_local = __n;
  this_local = this;
  sVar1 = max_size(this);
  sVar2 = size(this_local);
  if (sVar1 - sVar2 < __n_local) {
    if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    std::__throw_length_error(__s);
  }
  sVar1 = size(this_local);
  local_30 = size(this_local);
  puVar3 = max<>(&local_30,&__n_local);
  __len = *puVar3 + sVar1;
  sVar1 = size(this_local);
  if ((__len < sVar1) || (sVar2 = max_size(this_local), sVar1 = __len, sVar2 < __len)) {
    sVar1 = max_size(this_local);
  }
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return sVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// DWARF original name: operator-<std::__cxx11::basic_string<char>*,
// std::vector<std::__cxx11::basic_string<char> > >

difference_type __gnu_cxx::operator-<>(__normal_iterator<> *__lhs,__normal_iterator<> *__rhs)

{
  basic_string<> *pbVar1;
  basic_string<> **ppbVar2;
  __normal_iterator<> *__rhs_local;
  __normal_iterator<> *__lhs_local;
  
  ppbVar2 = __normal_iterator<>::base(__lhs);
  pbVar1 = *ppbVar2;
  ppbVar2 = __normal_iterator<>::base(__rhs);
  return (long)pbVar1 - (long)*ppbVar2 >> 5;
}



// DWARF original prototype: pointer
// _M_allocate(_Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this, size_t __n)

pointer __thiscall std::_Vector_base<>::_M_allocate(_Vector_base<> *this,size_t __n)

{
  pointer pbVar1;
  size_t __n_local;
  _Vector_base<> *this_local;
  
  if (__n == 0) {
    pbVar1 = (pointer)0x0;
  }
  else {
    pbVar1 = __new_allocator<>::allocate((__new_allocator<> *)this,__n,(void *)0x0);
  }
  return pbVar1;
}



pointer std::vector<>::_S_relocate
                  (pointer __first,pointer __last,pointer __result,_Tp_alloc_type *__alloc)

{
  pointer pbVar1;
  _Tp_alloc_type *__alloc_local;
  pointer __result_local;
  pointer __last_local;
  pointer __first_local;
  
  pbVar1 = _S_do_relocate(__first,__last,__result,__alloc);
  return pbVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: __uninitialized_move_if_noexcept_a<std::__cxx11::basic_string<char>*,
// std::__cxx11::basic_string<char>*, std::allocator<std::__cxx11::basic_string<char> > >

basic_string<> *
std::__uninitialized_move_if_noexcept_a<>
          (basic_string<> *__first,basic_string<> *__last,basic_string<> *__result,
          allocator<> *__alloc)

{
  move_iterator<> __last_00;
  move_iterator<> __first_00;
  basic_string<> *pbVar1;
  allocator<> *__alloc_local;
  basic_string<> *__result_local;
  basic_string<> *__last_local;
  basic_string<> *__first_local;
  
  __last_00 = __make_move_if_noexcept_iterator<>(__last);
  __first_00 = __make_move_if_noexcept_iterator<>(__first);
  pbVar1 = __uninitialized_copy_a<>(__first_00,__last_00,__result,__alloc);
  return pbVar1;
}



// DWARF original prototype: void
// deallocate(__new_allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>
// * this, basic_string<char,_std::char_traits<char>,_std::allocator<char>_> * __p, size_type __n)

void __thiscall
std::__new_allocator<>::deallocate(__new_allocator<> *this,basic_string<> *__p,size_type __n)

{
  size_type __n_local;
  basic_string<> *__p_local;
  __new_allocator<> *this_local;
  
  operator_delete(__p);
  return;
}



void std::_Destroy_aux<false>::__destroy<>(basic_string<> *__first,basic_string<> *__last)

{
  basic_string<> *__pointer;
  basic_string<> *__last_local;
  basic_string<> *__first_local;
  
  for (__first_local = __first; __first_local != __last; __first_local = __first_local + 1) {
    __pointer = __addressof<>(__first_local);
    _Destroy<>(__pointer);
  }
  return;
}



// DWARF original prototype: size_type
// max_size(vector<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this)

size_type __thiscall std::vector<>::max_size(vector<> *this)

{
  _Tp_alloc_type *__a;
  size_type sVar1;
  vector<> *this_local;
  
  __a = _Vector_base<>::_M_get_Tp_allocator
                  (&this->
                    super__Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
                  );
  sVar1 = _S_max_size(__a);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: max<long unsigned int>

ulong * std::max<>(ulong *__a,ulong *__b)

{
  ulong *__b_local;
  ulong *__a_local;
  
  if (*__a < *__b) {
    __a = __b;
  }
  return __a;
}



pointer std::vector<>::_S_do_relocate
                  (basic_string<> *__first,basic_string<> *__last,basic_string<> *__result,
                  allocator<> *__alloc)

{
  basic_string<> *pbVar1;
  _Tp_alloc_type *__alloc_local;
  pointer __result_local;
  pointer __last_local;
  pointer __first_local;
  
  pbVar1 = __relocate_a<>(__first,__last,__result,__alloc);
  return pbVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: __make_move_if_noexcept_iterator<std::__cxx11::basic_string<char> >

move_iterator<> std::__make_move_if_noexcept_iterator<>(basic_string<> *__i)

{
  long in_FS_OFFSET;
  basic_string<> *__i_local;
  move_iterator<> local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  move_iterator<>::move_iterator(&local_18,__i);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (move_iterator<>)local_18._M_current;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name:
// __uninitialized_copy_a<std::move_iterator<std::__cxx11::basic_string<char>*>,
// std::__cxx11::basic_string<char>*, std::__cxx11::basic_string<char> >

basic_string<> *
std::__uninitialized_copy_a<>
          (move_iterator<> __first,move_iterator<> __last,basic_string<> *__result,
          allocator<> *param_4)

{
  basic_string<> *pbVar1;
  allocator<> *param_6_local;
  basic_string<> *__result_local;
  move_iterator<> __last_local;
  move_iterator<> __first_local;
  
  pbVar1 = uninitialized_copy<>(__first,__last,__result);
  return pbVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: _Destroy<std::__cxx11::basic_string<char> >

void std::_Destroy<>(basic_string<> *__pointer)

{
  basic_string<> *__pointer_local;
  
  std::__cxx11::string::~string((string *)__pointer);
  return;
}



size_type std::vector<>::_S_max_size(_Tp_alloc_type *__a)

{
  ulong *puVar1;
  long in_FS_OFFSET;
  _Tp_alloc_type *__a_local;
  size_t __diffmax;
  size_t __allocmax;
  _Tp_alloc_type *local_28;
  _Tp_alloc_type *local_20;
  _Tp_alloc_type *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __diffmax = 0x3ffffffffffffff;
  __allocmax = 0x3ffffffffffffff;
  local_28 = __a;
  local_20 = __a;
  local_18 = __a;
  puVar1 = min<>(&__diffmax,&__allocmax);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return *puVar1;
}



// DWARF original prototype: _Tp_alloc_type *
// _M_get_Tp_allocator(_Vector_base<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>,_std::allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>_>
// * this)

_Tp_alloc_type * __thiscall std::_Vector_base<>::_M_get_Tp_allocator(_Vector_base<> *this)

{
  _Vector_base<> *this_local;
  
  return (_Tp_alloc_type *)this;
}



// DWARF original prototype: basic_string<char,_std::char_traits<char>,_std::allocator<char>_> *
// allocate(__new_allocator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>
// * this, size_type __n, void * param_2)

basic_string<> * __thiscall
std::__new_allocator<>::allocate(__new_allocator<> *this,size_type __n,void *param_2)

{
  basic_string<> *pbVar1;
  void *param_2_local;
  size_type __n_local;
  __new_allocator<> *this_local;
  
  if (0x3ffffffffffffff < __n) {
    if (0x7ffffffffffffff < __n) {
      std::__throw_bad_array_new_length();
    }
    std::__throw_bad_alloc();
  }
  pbVar1 = (basic_string<> *)operator_new(__n << 5);
  return pbVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: __relocate_a<std::__cxx11::basic_string<char>*,
// std::__cxx11::basic_string<char>*, std::allocator<std::__cxx11::basic_string<char> > >

basic_string<> *
std::__relocate_a<>(basic_string<> *__first,basic_string<> *__last,basic_string<> *__result,
                   allocator<> *__alloc)

{
  basic_string<> *pbVar1;
  basic_string<> *__last_00;
  basic_string<> *__first_00;
  allocator<> *__alloc_local;
  basic_string<> *__result_local;
  basic_string<> *__last_local;
  basic_string<> *__first_local;
  
  pbVar1 = __niter_base<>(__result);
  __last_00 = __niter_base<>(__last);
  __first_00 = __niter_base<>(__first);
  pbVar1 = __relocate_a_1<>(__first_00,__last_00,pbVar1,__alloc);
  return pbVar1;
}



// DWARF original prototype: void
// move_iterator(move_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*>
// * this, iterator_type __i)

void __thiscall std::move_iterator<>::move_iterator(move_iterator<> *this,iterator_type __i)

{
  type *ppbVar1;
  iterator_type __i_local;
  move_iterator<> *this_local;
  
  __i_local = __i;
  this_local = this;
  ppbVar1 = move<>(&__i_local);
  this_local->_M_current = *ppbVar1;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: uninitialized_copy<std::move_iterator<std::__cxx11::basic_string<char>*>,
// std::__cxx11::basic_string<char>*>

basic_string<> *
std::uninitialized_copy<>(move_iterator<> __first,move_iterator<> __last,basic_string<> *__result)

{
  basic_string<> *pbVar1;
  basic_string<> *__result_local;
  move_iterator<> __last_local;
  move_iterator<> __first_local;
  bool __can_memmove;
  bool __assignable;
  
  pbVar1 = __uninitialized_copy<false>::__uninit_copy<>(__first,__last,__result);
  return pbVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: min<long unsigned int>

ulong * std::min<>(ulong *__a,ulong *__b)

{
  ulong *__b_local;
  ulong *__a_local;
  
  if (*__b < *__a) {
    __a = __b;
  }
  return __a;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

basic_string<> * std::__niter_base<>(basic_string<> *__it)

{
  basic_string<> *__it_local;
  
  return __it;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: __relocate_a_1<std::__cxx11::basic_string<char>*,
// std::__cxx11::basic_string<char>*, std::allocator<std::__cxx11::basic_string<char> > >

basic_string<> *
std::__relocate_a_1<>
          (basic_string<> *__first,basic_string<> *__last,basic_string<> *__result,
          allocator<> *__alloc)

{
  basic_string<> *__orig;
  basic_string<> *__dest;
  allocator<> *__alloc_local;
  basic_string<> *__result_local;
  basic_string<> *__last_local;
  basic_string<> *__first_local;
  basic_string<> *__cur;
  
  __cur = __result;
  for (__first_local = __first; __first_local != __last; __first_local = __first_local + 1) {
    __orig = __addressof<>(__first_local);
    __dest = __addressof<>(__cur);
    __relocate_object_a<>(__dest,__orig,__alloc);
    __cur = __cur + 1;
  }
  return __cur;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

type * std::move<>(basic_string<> **__t)

{
  basic_string<> **__t_local;
  
  return __t;
}



// DWARF original name: __uninit_copy<std::move_iterator<std::__cxx11::basic_string<char>*>,
// std::__cxx11::basic_string<char>*>

basic_string<> *
std::__uninitialized_copy<false>::__uninit_copy<>
          (move_iterator<> __first,move_iterator<> __last,basic_string<> *__result)

{
  basic_string<> *pbVar1;
  basic_string<> *__result_local;
  move_iterator<> __last_local;
  move_iterator<> __first_local;
  
  pbVar1 = __do_uninit_copy<>(__first,__last,__result);
  return pbVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: __relocate_object_a<std::__cxx11::basic_string<char>,
// std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char> > >

void std::__relocate_object_a<>(basic_string<> *__dest,basic_string<> *__orig,allocator<> *__alloc)

{
  type *__t;
  basic_string<> *pbVar1;
  string *this;
  allocator<> *__alloc_local;
  basic_string<> *__orig_local;
  basic_string<> *__dest_local;
  
  __t = move<>(__orig);
  pbVar1 = forward<>(__t);
  this = (string *)operator_new(0x20,__dest);
  pbVar1 = forward<>(pbVar1);
  std::__cxx11::string::string(this,(string *)pbVar1);
  pbVar1 = __addressof<>(__orig);
  std::__cxx11::string::~string((string *)pbVar1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: __do_uninit_copy<std::move_iterator<std::__cxx11::basic_string<char>*>,
// std::__cxx11::basic_string<char>*>

basic_string<> *
std::__do_uninit_copy<>(move_iterator<> __first,move_iterator<> __last,basic_string<> *__result)

{
  bool bVar1;
  basic_string<> *__p;
  basic_string<> *__result_local;
  move_iterator<> __last_local;
  move_iterator<> __first_local;
  basic_string<> *__cur;
  
  __last_local._M_current = __last._M_current;
  __first_local._M_current = __first._M_current;
  __cur = __result;
  while( true ) {
                    // try { // try from 0010467e to 00104682 has its CatchHandler @ 0010468d
    bVar1 = operator!=<>(&__first_local,&__last_local);
    if (!bVar1) break;
    move_iterator<>::operator*(&__first_local);
    __p = __addressof<>(__cur);
    _Construct<>(__p);
    move_iterator<>::operator++(&__first_local);
    __cur = __cur + 1;
  }
  return __cur;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool std::operator!=<>(move_iterator<> *__x,move_iterator<> *__y)

{
  bool bVar1;
  move_iterator<> *__y_local;
  move_iterator<> *__x_local;
  
  bVar1 = operator==<>(__x,__y);
  return !bVar1;
}



// DWARF original prototype:
// move_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*> *
// operator++(move_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*>
// * this)

move_iterator<> * __thiscall std::move_iterator<>::operator++(move_iterator<> *this)

{
  move_iterator<> *this_local;
  
  this->_M_current = this->_M_current + 1;
  return this;
}



// DWARF original prototype: reference
// operator*(move_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*>
// * this)

reference __thiscall std::move_iterator<>::operator*(move_iterator<> *this)

{
  move_iterator<> *this_local;
  
  return this->_M_current;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: _Construct<std::__cxx11::basic_string<char>,
// std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >

void std::_Construct<>(basic_string<> *__p)

{
  string *this;
  basic_string<> *pbVar1;
  type *in_RSI;
  basic_string<> *__p_local;
  
  this = (string *)operator_new(0x20,__p);
  pbVar1 = forward<>(in_RSI);
  std::__cxx11::string::string(this,(string *)pbVar1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::__cxx11::basic_string<char> >

basic_string<> * std::forward<>(type *__t)

{
  type *__t_local;
  
  return __t;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool std::operator==<>(move_iterator<> *__x,move_iterator<> *__y)

{
  iterator_type pbVar1;
  iterator_type pbVar2;
  move_iterator<> *__y_local;
  move_iterator<> *__x_local;
  
  pbVar1 = move_iterator<>::base(__x);
  pbVar2 = move_iterator<>::base(__y);
  return pbVar1 == pbVar2;
}



// DWARF original prototype: iterator_type
// base(move_iterator<std::__cxx11::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>*>
// * this)

iterator_type __thiscall std::move_iterator<>::base(move_iterator<> *this)

{
  move_iterator<> *this_local;
  
  return this->_M_current;
}



// DWARF original prototype: void ClienteRed(ClienteRed * this)

void __thiscall ClienteRed::ClienteRed(ClienteRed *this)

{
  ClienteRed *this_local;
  
  this->socket_fd = -1;
  this->conectado = false;
  return;
}



// DWARF original prototype: void ~ClienteRed(ClienteRed * this, int __in_chrg)

void __thiscall ClienteRed::~ClienteRed(ClienteRed *this,int __in_chrg)

{
  ClienteRed *this_local;
  
  if (-1 < this->socket_fd) {
    close(this->socket_fd);
  }
  return;
}



// DWARF original prototype: bool conectar(ClienteRed * this, string * ip, int puerto)

bool __thiscall ClienteRed::conectar(ClienteRed *this,string *ip,int puerto)

{
  long lVar1;
  bool bVar2;
  int iVar3;
  ostream *poVar4;
  char *__cp;
  long in_FS_OFFSET;
  int puerto_local;
  string *ip_local;
  ClienteRed *this_local;
  sockaddr_in servidor_addr;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar3 = socket(2,1,0);
  this->socket_fd = iVar3;
  if (this->socket_fd < 0) {
    poVar4 = std::operator<<((ostream *)std::cerr," Error: no se pudo crear el socket");
    std::ostream::operator<<(poVar4,std::endl<>);
    bVar2 = false;
  }
  else {
    servidor_addr.sin_family = 2;
    servidor_addr.sin_port = htons((uint16_t)puerto);
    __cp = (char *)std::__cxx11::string::c_str();
    iVar3 = inet_pton(2,__cp,&servidor_addr.sin_addr);
    if (iVar3 < 1) {
      poVar4 = std::operator<<((ostream *)std::cerr,"Error: IP invalida ");
      std::ostream::operator<<(poVar4,std::endl<>);
      close(this->socket_fd);
      bVar2 = false;
    }
    else {
      poVar4 = std::operator<<((ostream *)std::cout,"Conectando a ");
      poVar4 = std::operator<<(poVar4,(string *)ip);
      poVar4 = std::operator<<(poVar4,":");
      poVar4 = (ostream *)std::ostream::operator<<(poVar4,puerto);
      poVar4 = std::operator<<(poVar4,"...");
      std::ostream::operator<<(poVar4,std::endl<>);
      iVar3 = connect(this->socket_fd,(sockaddr *)&servidor_addr,0x10);
      if (iVar3 < 0) {
        poVar4 = std::operator<<((ostream *)std::cerr,"Error: No se pudo conectar al servidor");
        std::ostream::operator<<(poVar4,std::endl<>);
        close(this->socket_fd);
        bVar2 = false;
      }
      else {
        this->conectado = true;
        poVar4 = std::operator<<((ostream *)std::cout,"Conectado con el servidor ");
        std::ostream::operator<<(poVar4,std::endl<>);
        bVar2 = true;
      }
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return bVar2;
}



// DWARF original prototype: bool enviarPeticion(ClienteRed * this, string * ip_servidor)

bool __thiscall ClienteRed::enviarPeticion(ClienteRed *this,string *ip_servidor)

{
  ostream *poVar1;
  size_t __n;
  void *__buf;
  ssize_t sVar2;
  long in_FS_OFFSET;
  bool bVar3;
  string *ip_servidor_local;
  ClienteRed *this_local;
  string peticion_str;
  stringstream peticion;
  ostream aoStack_198 [376];
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (this->conectado == true) {
    std::__cxx11::stringstream::stringstream((stringstream *)&peticion);
                    // try { // try from 00104af1 to 00104bac has its CatchHandler @ 00104c9c
    std::operator<<(aoStack_198,"GET /status HTTP/1.1\r\n");
    poVar1 = std::operator<<(aoStack_198,"Host: ");
    poVar1 = std::operator<<(poVar1,(string *)ip_servidor);
    std::operator<<(poVar1,"\r\n");
    std::operator<<(aoStack_198,"User-Agent: ClientePIA/1.0\r\n");
    std::operator<<(aoStack_198,"Connection: close\r\n");
    std::operator<<(aoStack_198,"\r\n");
    std::__cxx11::stringstream::str();
                    // try { // try from 00104bc1 to 00104c46 has its CatchHandler @ 00104c84
    poVar1 = std::operator<<((ostream *)std::cout,&DAT_001053a8);
    std::ostream::operator<<(poVar1,std::endl<>);
    __n = std::__cxx11::string::length();
    __buf = (void *)std::__cxx11::string::c_str();
    sVar2 = send(this->socket_fd,__buf,__n,0);
    bVar3 = -1 < sVar2;
    if (!bVar3) {
      poVar1 = std::operator<<((ostream *)std::cerr,&DAT_001053c8);
      std::ostream::operator<<(poVar1,std::endl<>);
    }
    std::__cxx11::string::~string((string *)&peticion_str);
    std::__cxx11::stringstream::~stringstream((stringstream *)&peticion);
  }
  else {
    poVar1 = std::operator<<((ostream *)std::cerr,"Error: No hay conexion");
    std::ostream::operator<<(poVar1,std::endl<>);
    bVar3 = false;
  }
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return bVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// DWARF original prototype: string recibirRespuesta(ClienteRed * this)

string * __thiscall ClienteRed::recibirRespuesta(string *__return_storage_ptr__,ClienteRed *this)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  ClienteRed *this_local;
  allocator local_461;
  ssize_t bytes_recibidos;
  allocator *local_458;
  allocator *local_450;
  string respuesta;
  char buffer [1024];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (this->conectado == true) {
    std::__cxx11::string::string((string *)&respuesta);
    while( true ) {
      bytes_recibidos = recv(this->socket_fd,buffer,0x3ff,0);
      if (bytes_recibidos < 1) break;
      buffer[bytes_recibidos] = '\0';
                    // try { // try from 00104d98 to 00104dbd has its CatchHandler @ 00104e9b
      std::__cxx11::string::operator+=((string *)&respuesta,buffer);
    }
    if (bytes_recibidos < 0) {
      local_450 = &local_461;
      iVar2 = 0x105402;
                    // try { // try from 00104e09 to 00104e0d has its CatchHandler @ 00104e82
      std::__cxx11::string::string
                ((string *)__return_storage_ptr__,"ERROR: Fallo la recepcion",&local_461);
      std::__new_allocator<char>::~__new_allocator((__new_allocator<char> *)&local_461,iVar2);
    }
    else {
      std::__cxx11::string::string((string *)__return_storage_ptr__,(string *)&respuesta);
    }
    std::__cxx11::string::~string((string *)&respuesta);
  }
  else {
    local_458 = &local_461;
    iVar2 = 0x1053ee;
                    // try { // try from 00104d46 to 00104d4a has its CatchHandler @ 00104e4c
    std::__cxx11::string::string((string *)__return_storage_ptr__,"ERROR: Sin conexion",&local_461);
    std::__new_allocator<char>::~__new_allocator((__new_allocator<char> *)&local_461,iVar2);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return __return_storage_ptr__;
}



void _fini(void)

{
  return;
}


